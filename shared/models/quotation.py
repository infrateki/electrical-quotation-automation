from typing import TypedDict, Dict, List, Any, Optional
from datetime import datetime


class CompanyInfo(TypedDict):
    """Company information structure."""
    name: str
    address: str
    phone: str
    email: str
    website: str
    registration_number: str
    tax_id: str
    logo_url: Optional[str]


class ClientInfo(TypedDict):
    """Client information structure."""
    name: str
    company: Optional[str]
    address: str
    phone: str
    email: str
    contact_person: Optional[str]


class LineItem(TypedDict):
    """Individual line item in quotation."""
    item_id: str
    description: str
    quantity: float
    unit: str
    unit_price: float
    total_price: float
    category: str
    notes: Optional[str]


class PricingSummary(TypedDict):
    """Pricing summary structure."""
    subtotal: float
    tax_rate: float
    tax_amount: float
    discount_percentage: float
    discount_amount: float
    total: float
    currency: str


class ProjectInfo(TypedDict):
    """Project information structure."""
    name: str
    description: str
    location: str
    start_date: Optional[str]
    estimated_duration: str
    project_type: str
    specifications: List[str]


class ApprovalInfo(TypedDict):
    """Approval requirements and signatures."""
    requires_client_signature: bool
    requires_manager_approval: bool
    approval_threshold: float
    approved_by: Optional[str]
    approved_date: Optional[str]
    client_signed: bool
    client_signature_date: Optional[str]


class QuotationMetadata(TypedDict):
    """Metadata for tracking quotation lifecycle."""
    created_at: str
    updated_at: str
    created_by: str
    version: int
    status: str  # draft, sent, approved, rejected, expired
    valid_until: str
    notes: List[str]


class AgentExecutionLog(TypedDict):
    """Log entry for agent execution."""
    agent_name: str
    executed_at: str
    status: str  # success, failed, skipped
    execution_time_ms: int
    error_message: Optional[str]


class QuotationState(TypedDict):
    """Complete state for quotation generation workflow.
    
    This TypedDict represents the shared state that flows through
    all agents in the LangGraph orchestration.
    """
    # Identifiers
    quotation_id: str
    quote_number: str
    
    # Header information
    header: Dict[str, Any]
    
    # Company information
    company_info: CompanyInfo
    
    # Client information
    client_info: ClientInfo
    
    # Project details
    project_info: ProjectInfo
    
    # Line items
    line_items: List[LineItem]
    
    # Pricing
    pricing_summary: PricingSummary
    
    # Terms and conditions
    terms_and_conditions: str
    
    # Footer information
    footer: Dict[str, Any]
    
    # Approval requirements
    approval_info: ApprovalInfo
    
    # Executive summary (generated by AI)
    executive_summary: Optional[str]
    
    # Risk assessment (generated by AI)
    risk_assessment: Optional[Dict[str, Any]]
    
    # Compliance check results
    compliance_status: Dict[str, bool]
    
    # Document generation settings
    document_format: str  # pdf, docx, html
    include_sections: List[str]
    
    # Metadata
    metadata: QuotationMetadata
    
    # Agent execution tracking
    agent_logs: List[AgentExecutionLog]
    
    # Error tracking
    errors: List[Dict[str, Any]]
    
    # Custom fields for flexibility
    custom_fields: Dict[str, Any]


# Helper functions for state management
def create_initial_state(quotation_id: str, created_by: str) -> QuotationState:
    """Create initial quotation state with default values."""
    now = datetime.utcnow().isoformat()
    
    return QuotationState(
        quotation_id=quotation_id,
        quote_number="",
        header={},
        company_info=CompanyInfo(
            name="",
            address="",
            phone="",
            email="",
            website="",
            registration_number="",
            tax_id="",
            logo_url=None
        ),
        client_info=ClientInfo(
            name="",
            company=None,
            address="",
            phone="",
            email="",
            contact_person=None
        ),
        project_info=ProjectInfo(
            name="",
            description="",
            location="",
            start_date=None,
            estimated_duration="",
            project_type="",
            specifications=[]
        ),
        line_items=[],
        pricing_summary=PricingSummary(
            subtotal=0.0,
            tax_rate=0.0,
            tax_amount=0.0,
            discount_percentage=0.0,
            discount_amount=0.0,
            total=0.0,
            currency="USD"
        ),
        terms_and_conditions="",
        footer={},
        approval_info=ApprovalInfo(
            requires_client_signature=True,
            requires_manager_approval=False,
            approval_threshold=0.0,
            approved_by=None,
            approved_date=None,
            client_signed=False,
            client_signature_date=None
        ),
        executive_summary=None,
        risk_assessment=None,
        compliance_status={},
        document_format="pdf",
        include_sections=[
            "header",
            "company_info",
            "client_info",
            "project_info",
            "line_items",
            "pricing_summary",
            "terms_and_conditions",
            "footer"
        ],
        metadata=QuotationMetadata(
            created_at=now,
            updated_at=now,
            created_by=created_by,
            version=1,
            status="draft",
            valid_until="",
            notes=[]
        ),
        agent_logs=[],
        errors=[],
        custom_fields={}
    )


def update_state_timestamp(state: QuotationState) -> None:
    """Update the state's updated_at timestamp."""
    state["metadata"]["updated_at"] = datetime.utcnow().isoformat()


def log_agent_execution(
    state: QuotationState,
    agent_name: str,
    status: str,
    execution_time_ms: int,
    error_message: Optional[str] = None
) -> None:
    """Log an agent's execution to the state."""
    log_entry = AgentExecutionLog(
        agent_name=agent_name,
        executed_at=datetime.utcnow().isoformat(),
        status=status,
        execution_time_ms=execution_time_ms,
        error_message=error_message
    )
    state["agent_logs"].append(log_entry)
    update_state_timestamp(state)